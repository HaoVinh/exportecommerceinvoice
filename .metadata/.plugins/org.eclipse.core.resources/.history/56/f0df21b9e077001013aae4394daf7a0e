package vinh.lixco.com.apiecommerce;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.HttpURLConnection;
import java.net.URL;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.List;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;
import javax.inject.Inject;
import javax.ws.rs.Consumes;
import javax.ws.rs.POST;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.Context;
import javax.ws.rs.core.HttpHeaders;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;

import lixco.com.entity.Customer;
import lixco.com.entity.CustomerPricingProgram;
import lixco.com.entity.EcomOrder;
import lixco.com.entity.EcomOrderDetail;
import lixco.com.entity.PricingProgram;
import lixco.com.entity.PricingProgramDetail;
import lixco.com.entity.Product;
import lixco.com.interfaces.ICustomerPricingProgramService;
import lixco.com.interfaces.ICustomerService;
import lixco.com.interfaces.IPricingProgramDetailService;
import lixco.com.interfaces.IPricingProgramService;
import lixco.com.interfaces.IProductService;
import lixco.com.service.EcomOrderDetailService;
import lixco.com.service.EcomOrderService;

@Path("shopee")

public class ShopeeAPIServlet {

	private static final long PARTNER_ID = 2012115L;
	private static final String API_PARTNER_KEY = "shpk76694e444a51764f786775544b7a64446577784f7652476b72556b485163";
	private static final long SHOP_ID = 779607831L;
	private static final Logger LOGGER = Logger.getLogger(ShopeeAPIServlet.class.getName());
	private static final ObjectMapper mapper = new ObjectMapper();
	private static final String BASE_URL = "https://partner.shopeemobile.com";

	@Inject
	private EcomOrderService ecomOrderService;

	@Inject
	private ShopeeTokenManager shopeeTokenManager;

	@Inject
	private EcomOrderDetailService ecomOrderDetailService;

	@POST
	@Path("/webhook/order")
	@Consumes(MediaType.APPLICATION_JSON)
	@Produces(MediaType.APPLICATION_JSON)
	public Response webhookShopee(@Context HttpHeaders headers, String inputJson) {
		LOGGER.info("Webhook Shopee: " + inputJson);
		try {
			JsonNode jsonNode = mapper.readTree(inputJson);
			JsonNode dataNode = jsonNode.path("data");

			if (dataNode.has("verify_info")) {
				ObjectNode verifyResp = mapper.createObjectNode();
				verifyResp.put("code", 0);
				verifyResp.put("message", "Verified OK");
				return Response.ok(verifyResp).build();
			}

			String orderSn = dataNode.path("ordersn").asText(null);
			String status = dataNode.path("status").asText(null);
			long updateTime = dataNode.path("update_time").asLong(0);

			if (orderSn == null || orderSn.trim().isEmpty() || status == null || status.trim().isEmpty()) {
				throw new IllegalArgumentException("Missing or invalid ordersn or status in Shopee webhook");
			}
			OrderDTO orderDTO = new OrderDTO();
			orderDTO.setOrderId(orderSn);
			orderDTO.setOrder_status(status);
			orderDTO.setUpdatedAt(updateTime > 0 ? new Date(updateTime * 1000) : new Date());
			orderDTO.seteCommerceType("Shopee");

			try {
				OrderDTO fetchedDTO = fetchOrder(orderSn);
				if (fetchedDTO != null) {
					String webhookStatus = status;
					Date webhookUpdateTime = updateTime > 0 ? new Date(updateTime * 1000) : new Date();

					// copy dữ liệu cần từ API sang orderDTO
					orderDTO = fetchedDTO;
					orderDTO.setOrder_status(webhookStatus); // luôn dùng trạng thái từ webhook
					orderDTO.setUpdatedAt(webhookUpdateTime);
				}
				fetchEscrowDetails(orderDTO);
			} catch (Exception e) {
				LOGGER.warning("Failed to fetch order or escrow details for orderSn: " + orderSn + ", error: "
						+ e.getMessage());
			}

			saveOrUpdateOrder(orderDTO);

			ObjectNode successResp = mapper.createObjectNode();
			successResp.put("status", "success");
			successResp.put("message", "Shopee webhook processed successfully");
			successResp.put("ordersn", orderSn);
			successResp.put("order_status", status);
			return Response.ok(successResp).build();

		} catch (Exception e) {
			LOGGER.severe("Webhook Shopee error: " + e.getMessage());
			ObjectNode err = mapper.createObjectNode();
			err.put("error", e.getMessage());
			return Response.status(500).entity(err).build();
		}
	}

	public OrderDTO fetchOrder(String orderSn) throws Exception {
		if (orderSn == null || orderSn.trim().isEmpty()) {
			throw new IllegalArgumentException("orderSn cannot be null or empty");
		}

		String accessToken = shopeeTokenManager.getAccessToken();
		long timestamp = System.currentTimeMillis() / 1000L;
		String path = "/api/v2/order/get_order_detail";
		String baseString = PARTNER_ID + path + timestamp + accessToken + SHOP_ID;
		String sign = generateHmacSHA256(baseString, API_PARTNER_KEY);

		String url = BASE_URL + path + "?partner_id=" + PARTNER_ID + "&timestamp=" + timestamp + "&access_token="
				+ accessToken + "&shop_id=" + SHOP_ID + "&sign=" + sign + "&order_sn_list=" + orderSn
				+ "&response_optional_fields=buyer_user_id,buyer_username,recipient_address,item_list,order_status,create_time,update_time,total_amount,payment_method,shipping_carrier";

		int maxRetries = 5;
		long delayMillis = 5000;
		IOException lastException = null;

		for (int attempt = 1; attempt <= maxRetries; attempt++) {
			HttpURLConnection conn = null;
			try {
				conn = (HttpURLConnection) new URL(url).openConnection();
				conn.setRequestMethod("GET");
				conn.setConnectTimeout(30000);
				conn.setReadTimeout(10000);
				conn.setRequestProperty("Accept", "application/json");

				int responseCode = conn.getResponseCode();
				InputStream inputStream = (responseCode == 200) ? conn.getInputStream() : conn.getErrorStream();

				StringBuilder responseBuilder = new StringBuilder();
				try (BufferedReader in = new BufferedReader(new InputStreamReader(inputStream))) {
					String line;
					while ((line = in.readLine()) != null) {
						responseBuilder.append(line);
					}
				}

				String jsonResponse = responseBuilder.toString();
				LOGGER.info("API Response for orderSn " + orderSn + ": " + jsonResponse);

				if (responseCode != 200) {
					throw new IOException("HTTP error code: " + responseCode + ", Response: " + jsonResponse);
				}

				JsonNode root = mapper.readTree(jsonResponse);
				JsonNode orderList = root.path("response").path("order_list");

				if (orderList.isArray() && orderList.size() > 0) {
					JsonNode orderData = orderList.get(0);
					String responseOrderSn = orderData.path("order_sn").asText(null);
					LOGGER.info("Response order_sn: " + responseOrderSn);
					if (responseOrderSn == null || responseOrderSn.isEmpty()) {
						throw new RuntimeException("Order SN missing in response for order_sn: " + orderSn);
					}
					if (!orderSn.equals(responseOrderSn)) {
						throw new RuntimeException("Order SN from response (" + responseOrderSn
								+ ") does not match requested order SN (" + orderSn + ")");
					}
					return parseOrderDTO(orderData, orderSn);
				} else {
					throw new RuntimeException("Không có đơn hàng nào trả về từ Shopee cho order_sn: " + orderSn);
				}

			} catch (IOException ex) {
				lastException = ex;
//                LOGGER.warning("Attempt " + attempt + " failed for orderSn " + orderSn + ": " + ex.getMessage());
				Thread.sleep(delayMillis);
			} finally {
				if (conn != null) {
					conn.disconnect();
				}
			}
		}

		throw new IOException("Failed to fetch order details after " + maxRetries + " attempts.", lastException);
	}

	private void fetchEscrowDetails(OrderDTO dto) throws Exception {
		if (dto == null || dto.getOrderId() == null) {
			throw new IllegalArgumentException("OrderDTO or orderId cannot be null");
		}

		String orderSn = dto.getOrderId();
		String accessToken = shopeeTokenManager.getAccessToken();
		long timestamp = System.currentTimeMillis() / 1000L;
		String path = "/api/v2/payment/get_escrow_detail";
		String baseString = PARTNER_ID + path + timestamp + accessToken + SHOP_ID;
		String sign = generateHmacSHA256(baseString, API_PARTNER_KEY);

		String url = BASE_URL + path + "?partner_id=" + PARTNER_ID + "&timestamp=" + timestamp + "&access_token="
				+ accessToken + "&shop_id=" + SHOP_ID + "&sign=" + sign + "&order_sn=" + orderSn;

		System.out.println(url);

		int maxRetries = 5;
		long delayMillis = 5000;
		IOException lastException = null;

		for (int attempt = 1; attempt <= maxRetries; attempt++) {
			HttpURLConnection conn = null;
			try {
				conn = (HttpURLConnection) new URL(url).openConnection();
				conn.setRequestMethod("GET");
				conn.setConnectTimeout(30000);
				conn.setReadTimeout(10000);
				conn.setRequestProperty("Accept", "application/json");

				int responseCode = conn.getResponseCode();
				InputStream inputStream = (responseCode == 200) ? conn.getInputStream() : conn.getErrorStream();

				StringBuilder responseBuilder = new StringBuilder();
				try (BufferedReader in = new BufferedReader(new InputStreamReader(inputStream))) {
					String line;
					while ((line = in.readLine()) != null) {
						responseBuilder.append(line);
					}
				}

				String jsonResponse = responseBuilder.toString();
//                LOGGER.info("Escrow API Response for orderSn " + orderSn + ": " + jsonResponse);

				if (responseCode != 200) {
					throw new IOException("HTTP error code: " + responseCode + ", Response: " + jsonResponse);
				}

				JsonNode root = mapper.readTree(jsonResponse);
				JsonNode orderIncome = root.path("response").path("order_income");
				JsonNode items = orderIncome.path("items");

				if (items.isArray() && items.size() > 0) {
					double totalShopeeDiscount = 0.0;
					double totalSellerDiscount = 0.0;
					double totalComboDiscount = 0.0;
					double discountPrice = 0.0;

					for (JsonNode item : items) {
						totalShopeeDiscount += item.path("shopee_discount").asDouble(0.0);
						totalSellerDiscount += item.path("discount_from_voucher_seller").asDouble(0.0);
						totalComboDiscount += (item.path("selling_price").asDouble(0.0)
								- item.path("discounted_price").asDouble(0.0));
						discountPrice += item.path("discounted_price").asDouble(0.0);
					}

					dto.setShopeeDiscount(totalShopeeDiscount);
					dto.setSellerDiscount(totalSellerDiscount);
					dto.setComboDiscount(totalComboDiscount);
					dto.setDiscountedPrice(discountPrice);

					double lastPrice = (discountPrice + totalShopeeDiscount - totalSellerDiscount - totalComboDiscount)
							/ (1.1);
					dto.setLastPrice(lastPrice);

//                    LOGGER.info("Escrow details parsed for orderSn: " + orderSn + ", Shopee discount: "
//                            + totalShopeeDiscount + ", Seller discount: " + totalSellerDiscount + ", Combo discount: "
//                            + totalComboDiscount + ", Last price: " + lastPrice);

				} else {
					LOGGER.warning("No items found in escrow details for orderSn: " + orderSn);
					dto.setShopeeDiscount(0.0);
					dto.setSellerDiscount(0.0);
					dto.setComboDiscount(0.0);
					dto.setLastPrice(dto.getPrice() != null ? dto.getPrice() : 0.0);
				}

				return;

			} catch (IOException ex) {
				lastException = ex;
				LOGGER.warning("Attempt " + attempt + " failed for escrow details of orderSn " + orderSn + ": "
						+ ex.getMessage());
				Thread.sleep(delayMillis);
			} finally {
				if (conn != null) {
					conn.disconnect();
				}
			}
		}

		if (lastException != null) {
			throw new IOException("Failed to fetch escrow details after " + maxRetries + " attempts.", lastException);
		}
	}

	private OrderDTO parseOrderDTO(JsonNode data, String orderSn) throws Exception {
		OrderDTO dto = new OrderDTO();
		dto.setOrderId(orderSn);
		LOGGER.info("Setting orderId in OrderDTO: " + orderSn);

		dto.setOrder_status(data.path("order_status").asText());
		dto.setCreatedAt(new Date(data.path("create_time").asLong(0) * 1000));
		dto.setUpdatedAt(new Date(data.path("update_time").asLong(0) * 1000));
		dto.setPrice(data.path("total_amount").asDouble(0.0));

		dto.setCustomerFirstName(data.path("recipient_address").path("name").asText(""));
		dto.setCustomerLastName("");
		dto.seteCommerceType("Shopee");

		List<OrderDetailDTO> details = new ArrayList<>();
		JsonNode itemList = data.path("item_list");
		int index = 1;

		for (JsonNode item : itemList) {
			OrderDetailDTO detail = new OrderDetailDTO();
			detail.setOrderItemId(item.path("order_item_id").asText(""));
			String itemName = item.path("item_name").asText("");
			String modelName = item.path("model_name").asText("");
			if (!modelName.isEmpty()) {
				itemName += " (" + modelName + ")";
			}
			detail.setName(itemName);
			String sku = item.path("model_sku").asText();
			if (sku == null || sku.trim().isEmpty()) {
				sku = item.path("item_sku").asText("");
			}
			detail.setSku(sku);
			detail.setItemPrice(item.path("model_discounted_price").asDouble(0.0));
			detail.setStt(index++);
			detail.setQuantity(item.path("model_quantity_purchased").asInt(0));
			detail.setOrderId(orderSn);
			boolean isVariant = !item.path("main_item").asBoolean(true) && !item.path("model_sku").asText("").isEmpty();
			detail.setVariant(isVariant);
			detail.setLoaitmdt("Shopee");
			details.add(detail);
		}

		dto.setOrderDetails(details);
		fetchEscrowDetails(dto);

		// Phân bổ lastPrice cho OrderDetails dựa trên itemPrice
		double totalLastPrice = dto.getLastPrice() != null ? dto.getLastPrice() : 0.0;
		if (!details.isEmpty() && totalLastPrice > 0) {
			// Lọc các sản phẩm có itemPrice > 0
			List<OrderDetailDTO> validDetails = details.stream().filter(detail -> detail.getItemPrice() > 0)
					.collect(Collectors.toList());

			if (!validDetails.isEmpty()) {
				// Tính tổng itemPrice của các sản phẩm hợp lệ
				double totalItemPrice = validDetails.stream().mapToDouble(OrderDetailDTO::getItemPrice).sum();

				// Phân bổ lastPrice dựa trên tỉ lệ itemPrice
				double remainingLastPrice = totalLastPrice;
				for (OrderDetailDTO detail : validDetails) {
					double allocatedPrice = (detail.getItemPrice() / totalItemPrice) * totalLastPrice;
					detail.setLastItemPrice(Math.max(0, Math.min(allocatedPrice, remainingLastPrice))); // Đảm bảo không
																										// âm
					remainingLastPrice -= detail.getLastItemPrice();
				}

				// Điều chỉnh sản phẩm cuối cùng để khớp với totalLastPrice
				if (!validDetails.isEmpty()) {
					OrderDetailDTO lastDetail = validDetails.get(validDetails.size() - 1);
					lastDetail.setLastItemPrice(lastDetail.getLastItemPrice() + remainingLastPrice);
				}

				// Gán lastItemPrice = 0 cho các sản phẩm có itemPrice = 0
				for (OrderDetailDTO detail : details) {
					if (detail.getItemPrice() <= 0) {
						detail.setLastItemPrice(0.0);
					}
				}

				// Tính unitPrice = lastItemPrice / quantity
				for (OrderDetailDTO detail : details) {
					if (detail.getQuantity() > 0) {
						detail.setUnitPrice(detail.getLastItemPrice() / detail.getQuantity());
					} else {
						detail.setUnitPrice(0.0); // Gán 0 nếu quantity = 0
					}
				}
			}
		}

		return dto;
	}

	public void saveOrUpdateOrder(OrderDTO dto) {
		String orderNumber = dto.getOrderId();
		String platform = dto.geteCommerceType(); // Luôn là "Shopee"

		// Tìm theo orderNumber và loaitmdt để tránh nhầm sàn
		EcomOrder existing = ecomOrderService.findByCodeAndPlatform(orderNumber, platform);
		EcomOrder order;

		if (existing == null) {
			order = new EcomOrder();
			order.setOrderNumber(orderNumber);
			order.setCustomerFirstName(dto.getCustomerFirstName());
			order.setCustomerLastName(dto.getCustomerLastName());
			order.setCreatedAt(dto.getCreatedAt());
			order.setLoaitmdt(platform);
		} else {
			order = existing;
		}

		order.setUpdatedAt(dto.getUpdatedAt());
		order.setPrice(dto.getPrice());
		order.setStatus(dto.getOrder_status());
		order.setThoigiancapnhat(new Date());
		order.setComboDiscount(dto.getComboDiscount());
		order.setShopeeDiscount(dto.getShopeeDiscount());
		order.setSellerDiscount(dto.getSellerDiscount());
		order.setDiscountedPrice(dto.getDiscountedPrice());
		order.setLastPrice(dto.getLastPrice()); // Giữ nguyên lastPrice từ fetchEscrowDetails

		if (existing == null) {
			ecomOrderService.create(order);
			LOGGER.info("Saved new Shopee order: " + orderNumber);
		} else {
			ecomOrderService.update(order);
			LOGGER.info("Updated Shopee order: " + orderNumber);
		}

		// Xóa các chi tiết cũ
		List<EcomOrderDetail> oldDetails = ecomOrderDetailService.findByCodeAndPlatform(orderNumber, platform);
		for (EcomOrderDetail old : oldDetails) {
			ecomOrderDetailService.delete(old);
		}

		// Tách SKU và lưu chi tiết
		for (OrderDetailDTO orddt : dto.getOrderDetails()) {
			List<OrderDetailDTO> splitDetails = splitSku(orddt);
			for (OrderDetailDTO splitDetail : splitDetails) {
				EcomOrderDetail orddetail = new EcomOrderDetail();
				orddetail.setOrder(order);
				orddetail.setOrderItemNumber(splitDetail.getOrderItemId());
				orddetail.setName(splitDetail.getName());
				orddetail.setSku(splitDetail.getSku());
				orddetail.setLoaitmdt(platform);
				orddetail.setVariant(splitDetail.isVariant());
				orddetail.setQuantity(splitDetail.getQuantity());
				orddetail.setItemPrice(splitDetail.getItemPrice());
				orddetail.setSplitPrice(splitDetail.getLastItemPrice()); // Lưu lastItemPrice
				orddetail.setUnitPrice(splitDetail.getUnitPrice()); // Lưu unitPrice
				orddetail.setOrderId(orderNumber);
				ecomOrderDetailService.create(orddetail);
				LOGGER.info("Saved order detail: orderItemNumber=" + splitDetail.getOrderItemId() + ", sku="
						+ splitDetail.getSku() + ", quantity=" + splitDetail.getQuantity() + ", lastItemPrice="
						+ splitDetail.getLastItemPrice() + ", unitPrice=" + splitDetail.getUnitPrice());
			}
		}
	}

	@Inject
	private ICustomerPricingProgramService customerPricingProgramService;

	@Inject
	private IProductService productService;

	@Inject
	private IPricingProgramService priceProgramService;

	@Inject
	private ICustomerService customerService;

	@Inject
	private IPricingProgramDetailService pricingProgramDetailService;

	private List<OrderDetailDTO> splitSku(OrderDetailDTO detail) {
		Customer customer = new Customer();
		Product productA = new Product();
		Product productB = new Product();
		customer = customerService.selectByCode("CO648");
//		CustomerPricingProgram customerPricingProgram = customerPricingProgramService.(customer.getId());
		PricingProgram pricingProgram = new PricingProgram();
		pricingProgram = priceProgramService.findByCode("DG027968");
		List<PricingProgramDetail> pricingProgramDetails = pricingProgramDetailService
				.findAllByPricingProgram(pricingProgram.getId());
		List<OrderDetailDTO> result = new ArrayList<>();
		String skuString = detail.getSku();
		
		//Nếu không có mã SKU để tách
		if (skuString == null || skuString.trim().isEmpty()) {
			result.add(detail);
			return result;
		}

		skuString = skuString.trim();
		int originalQuantity = detail.getQuantity();
		double originalLastItemPrice = detail.getLastItemPrice() != null ? detail.getLastItemPrice() : 0.0;

		// Kiểm tra tiền tố 2C, 3C hoặc A + B + C
		Pattern pattern = Pattern.compile("^(\\d+)C\\s*-\\s*(.+)$");
		Matcher matcher = pattern.matcher(skuString);
		String remainingSku = skuString;

		if (matcher.matches()) {
			int prefixNumber = Integer.parseInt(matcher.group(1));
			remainingSku = matcher.group(2).trim();
			String[] skuParts = remainingSku.split("\\s*\\+\\s*");

			if ((prefixNumber == 2 || prefixNumber == 3) && skuParts.length == 2 && originalLastItemPrice > 0) {
				// Xử lý 2C hoặc 3C với mã A và B
				OrderDetailDTO detailA = new OrderDetailDTO();
				OrderDetailDTO detailB = new OrderDetailDTO();

				// Tách tên dựa trên "tặng"
				String originalName = detail.getName();
				int tặngIndex = originalName.toLowerCase().indexOf("tặng");
				String nameA = tặngIndex != -1 ? originalName.substring(0, tặngIndex).trim() : originalName;
				String nameB = tặngIndex != -1 ? originalName.substring(tặngIndex + "tặng".length()).trim()
						: originalName;
				if (tặngIndex == -1) {
					LOGGER.warning("No 'tặng' found in name: " + originalName + ", using full name for both.");
				}
				nameA = nameA.isEmpty() ? nameA
						: Character.toUpperCase(nameA.charAt(0)) + (nameA.length() > 1 ? nameA.substring(1) : "");
				nameB = nameB.isEmpty() ? nameB
						: Character.toUpperCase(nameB.charAt(0)) + (nameB.length() > 1 ? nameB.substring(1) : "");

				// Tìm productA và productB dựa trên SKU
				productA = productService.selectByCode(skuParts[0].trim());
				productB = productService.selectByCode(skuParts[1].trim());

				// Tìm PricingProgramDetail tương ứng và gán itemPrice
				double itemPriceA = 0.0;
				double itemPriceB = 0.0;
				for (PricingProgramDetail item : pricingProgramDetails) {
					if (item.getProduct() != null && productA.getId() != 0
							&& item.getProduct().getProduct_code().equals(productA.getProduct_code())) {
						itemPriceA = item.getUnit_price() != 0 ? item.getUnit_price() : 0.0;
					}
					if (item.getProduct() != null && productB.getId() != 0
							&& item.getProduct().getProduct_code().equals(productB.getProduct_code())) {
						itemPriceB = item.getUnit_price() != 0 ? item.getUnit_price() : 0.0;
					}
				}

				// Phân bổ lastItemPrice dựa trên itemPrice cao hơn với thuật toán cải tiến
				double[] itemPrices = {itemPriceA, itemPriceB};
				double[] ratios = calculateAllocationRatios(itemPrices);
				double ratioA = ratios[0];
				double ratioB = ratios[1];

				double lastItemPriceA = originalLastItemPrice * ratioA;
				double lastItemPriceB = originalLastItemPrice * ratioB;

				detailA.setOrderItemId(detail.getOrderItemId());
				detailA.setName(nameA);
				detailA.setSku(skuParts[0].trim());
				detailA.setItemPrice(itemPriceA);
				detailA.setLastItemPrice(lastItemPriceA);
				detailA.setStt(detail.getStt());
				detailA.setQuantity(prefixNumber == 3 ? 3 : 2); // SL mã A là 3 cho 3C, 2 cho 2C
				detailA.setOrderId(detail.getOrderId());
				detailA.setVariant(detail.isVariant());
				detailA.setLoaitmdt(detail.getLoaitmdt());
				detailA.setUnitPrice(lastItemPriceA / (prefixNumber == 3 ? 3 : 2));
				LOGGER.info((prefixNumber == 3 ? "3C" : "2C") + " - detailA: sku=" + detailA.getSku()
						+ ", itemPrice=" + itemPriceA + ", lastItemPrice=" + lastItemPriceA
						+ ", unitPrice=" + (lastItemPriceA / (prefixNumber == 3 ? 3 : 2))
						+ ", quantity=" + (prefixNumber == 3 ? 3 : 2) + ", ratio=" + String.format("%.2f", ratioA));

				detailB.setOrderItemId(detail.getOrderItemId());
				detailB.setName(nameB);
				detailB.setSku(skuParts[1].trim());
				detailB.setItemPrice(itemPriceB);
				detailB.setLastItemPrice(lastItemPriceB);
				detailB.setStt(detail.getStt());
				detailB.setQuantity(1); // SL mã B là 1
				detailB.setOrderId(detail.getOrderId());
				detailB.setVariant(detail.isVariant());
				detailB.setLoaitmdt(detail.getLoaitmdt());
				detailB.setUnitPrice(lastItemPriceB / 1);
				LOGGER.info((prefixNumber == 3 ? "3C" : "2C") + " - detailB: sku=" + detailB.getSku()
						+ ", itemPrice=" + itemPriceB + ", lastItemPrice=" + lastItemPriceB
						+ ", unitPrice=" + (lastItemPriceB / 1) + ", quantity=1" + ", ratio=" + String.format("%.2f", ratioB));

				result.add(detailA);
				result.add(detailB);
			}
		} else {
			// Xử lý SKU dạng A + B + C
			String[] skuParts = skuString.split("\\s*\\+\\s*");
			if (skuParts.length > 1 && originalLastItemPrice > 0) {
				List<OrderDetailDTO> tempDetails = new ArrayList<>();
				for (String part : skuParts) {
					if (!part.trim().isEmpty()) {
						OrderDetailDTO tempDetail = new OrderDetailDTO();
						Product product = productService.selectByCode(part.trim());
						double itemPrice = 0.0;
						for (PricingProgramDetail item : pricingProgramDetails) {
							if (item.getProduct() != null && product.getId() != 0
									&& item.getProduct().getProduct_code().equals(product.getProduct_code())) {
								itemPrice = item.getUnit_price() != 0 ? item.getUnit_price() : 0.0;
							}
						}
						tempDetail.setSku(part.trim());
						tempDetail.setItemPrice(itemPrice);
						tempDetails.add(tempDetail);
					}
				}

				// Sắp xếp theo itemPrice giảm dần để dễ theo dõi
				tempDetails.sort((d1, d2) -> Double.compare(d2.getItemPrice(), d1.getItemPrice()));

				// Tính tỷ lệ phân bổ sử dụng phương thức helper
				double[] itemPricesArray = tempDetails.stream().mapToDouble(OrderDetailDTO::getItemPrice).toArray();
				double[] ratios = calculateAllocationRatios(itemPricesArray);

				// Phân bổ lastItemPrice dựa trên tỷ lệ đã tính
				for (int i = 0; i < tempDetails.size(); i++) {
					OrderDetailDTO newDetail = new OrderDetailDTO();
					newDetail.setOrderItemId(detail.getOrderItemId());
					newDetail.setName(detail.getName());
					newDetail.setSku(tempDetails.get(i).getSku());
					newDetail.setItemPrice(tempDetails.get(i).getItemPrice());

					double allocatedLastItemPrice = originalLastItemPrice * ratios[i];

					newDetail.setLastItemPrice(allocatedLastItemPrice);
					newDetail.setStt(detail.getStt());
					newDetail.setQuantity(1); // Mặc định quantity=1 cho mỗi mã
					newDetail.setOrderId(detail.getOrderId());
					newDetail.setVariant(detail.isVariant());
					newDetail.setLoaitmdt(detail.getLoaitmdt());
					newDetail.setUnitPrice(allocatedLastItemPrice / 1);
					result.add(newDetail);

					LOGGER.info("A+B+C - detail" + (i+1) + ": sku=" + newDetail.getSku()
							+ ", itemPrice=" + newDetail.getItemPrice()
							+ ", lastItemPrice=" + allocatedLastItemPrice
							+ ", unitPrice=" + newDetail.getUnitPrice()
							+ ", quantity=1, ratio=" + String.format("%.3f", ratios[i]));
				}
			} else {
				// Trường hợp 1 mã, giữ nguyên và tìm itemPrice
				OrderDetailDTO newDetail = new OrderDetailDTO();
				newDetail.setOrderItemId(detail.getOrderItemId());
				newDetail.setName(detail.getName());
				newDetail.setSku(skuString);

				// Tìm itemPrice cho SKU này
				Product product = productService.selectByCode(skuString);
				double itemPrice = 0.0;
				for (PricingProgramDetail item : pricingProgramDetails) {
					if (item.getProduct() != null && product.getId() != 0
							&& item.getProduct().getProduct_code().equals(product.getProduct_code())) {
						itemPrice = item.getUnit_price() != 0 ? item.getUnit_price() : 0.0;
						break;
					}
				}

				newDetail.setItemPrice(itemPrice);
				newDetail.setLastItemPrice(originalLastItemPrice);
				newDetail.setStt(detail.getStt());
				newDetail.setQuantity(originalQuantity);
				newDetail.setOrderId(detail.getOrderId());
				newDetail.setVariant(detail.isVariant());
				newDetail.setLoaitmdt(detail.getLoaitmdt());
				newDetail.setUnitPrice(originalLastItemPrice / originalQuantity);
				result.add(newDetail);

				LOGGER.info("Single SKU: sku=" + skuString + ", itemPrice=" + itemPrice
						+ ", lastItemPrice=" + originalLastItemPrice + ", unitPrice="
						+ (originalLastItemPrice / originalQuantity) + ", quantity=" + originalQuantity);
			}
		}

		return result;
	}

	/**
	 * Tính toán tỷ lệ phân bổ dựa trên đơn giá với trọng số ưu tiên cho giá cao hơn
	 * @param itemPrices Danh sách đơn giá các SKU
	 * @return Mảng tỷ lệ phân bổ tương ứng
	 */
	private double[] calculateAllocationRatios(double[] itemPrices) {
		double totalPrice = Arrays.stream(itemPrices).sum();
		double[] ratios = new double[itemPrices.length];

		if (totalPrice <= 0) {
			// Nếu tất cả đơn giá = 0, chia đều
			Arrays.fill(ratios, 1.0 / itemPrices.length);
			return ratios;
		}

		// Tìm giá cao nhất để làm chuẩn
		double maxPrice = Arrays.stream(itemPrices).max().orElse(1.0);

		// Tính tỷ lệ cơ bản và áp dụng trọng số
		double totalWeightedRatio = 0.0;
		for (int i = 0; i < itemPrices.length; i++) {
			double baseRatio = itemPrices[i] / totalPrice;
			// Tăng trọng số cho SKU có giá cao (hệ số 0.4 để tăng tối đa 40%)
			double weightFactor = 0.4 * (itemPrices[i] / maxPrice);
			ratios[i] = baseRatio + (baseRatio * weightFactor);
			totalWeightedRatio += ratios[i];
		}

		// Chuẩn hóa để tổng = 1.0
		for (int i = 0; i < ratios.length; i++) {
			ratios[i] = ratios[i] / totalWeightedRatio;
			// Đảm bảo không vượt quá 80% cho bất kỳ SKU nào
			ratios[i] = Math.min(0.8, ratios[i]);
		}

		// Điều chỉnh lại để tổng = 1.0 sau khi giới hạn 80%
		double actualTotal = Arrays.stream(ratios).sum();
		if (actualTotal > 0) {
			for (int i = 0; i < ratios.length; i++) {
				ratios[i] = ratios[i] / actualTotal;
			}
		}

		return ratios;
	}

	private String generateHmacSHA256(String data, String key) throws Exception {
		Mac mac = Mac.getInstance("HmacSHA256");
		SecretKeySpec secretKey = new SecretKeySpec(key.getBytes(StandardCharsets.UTF_8), "HmacSHA256");
		mac.init(secretKey);
		byte[] hashBytes = mac.doFinal(data.getBytes(StandardCharsets.UTF_8));
		StringBuilder sb = new StringBuilder();
		for (byte b : hashBytes) {
			sb.append(String.format("%02x", b));
		}
		return sb.toString();
	}

	private static ShopeeAPIServlet instance = new ShopeeAPIServlet();

	public static ShopeeAPIServlet getInstance() {
		return instance;
	}

	public void setShopeeTokenManager(ShopeeTokenManager manager) {
		this.shopeeTokenManager = manager;
	}
}